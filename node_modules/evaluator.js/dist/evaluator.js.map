{"version":3,"file":"evaluator.js","sources":["../src/config.js","../src/index.ts"],"sourcesContent":["const symbols = {\n\t'^': { infix: '_POW' },\n\t'*': { infix: '_MUL' },\n\t'/': { infix: '_DIV' },\n\t'%': { infix: '_MOD' },\n\t'+': { infix: '_ADD', prefix: '_POS' },\n\t'-': { infix: '_SUB', prefix: '_NEG' },\n};\n\nconst factorial = (x) => (x >= 0) ? ((x < 2) ? 1 : x * factorial(x - 1)) : NaN;\n\nconst operators = {\n\t'_POW': { name: 'Power', precedence: 4, associativity: 'right', method: (x, y) => x ** y },\n\t'_POS': { name: 'Positive', precedence: 3, associativity: 'right', method: (x) => x },\n\t'_NEG': { name: 'Negative', precedence: 3, associativity: 'right', method: (x) => -x },\n\t'_MUL': { name: 'Multiply', precedence: 2, associativity: 'left', method: (x, y) => x * y },\n\t'_DIV': { name: 'Divide', precedence: 2, associativity: 'left', method: (x, y) => x / y },\n\t'_MOD': { name: 'Modulo', precedence: 2, associativity: 'left', method: (x, y) => x % y },\n\t'_ADD': { name: 'Add', precedence: 1, associativity: 'left', method: (x, y) => x + y },\n\t'_SUB': { name: 'Subtract', precedence: 1, associativity: 'left', method: (x, y) => x - y },\n};\n\nconst constants = {\n\t'E': Math.E,\n\t'LN2': Math.LN2,\n\t'LN10': Math.LN10,\n\t'LOG2E': Math.LOG2E,\n\t'LOG10E': Math.LOG10E,\n\t'PHI': (1 + Math.sqrt(5)) / 2,\n\t'PI': Math.PI,\n\t'SQRT1_2': Math.SQRT1_2,\n\t'SQRT2': Math.SQRT2,\n\t'TAU': 2 * Math.PI,\n};\n\nconst methods = {\n\t'ABS': (x) => Math.abs(x),\n\t'ACOS': (x) => Math.acos(x),\n\t'ACOSH': (x) => Math.acosh(x),\n\t'ADD': (x, y) => x + y,\n\t'ASIN': (x) => Math.asin(x),\n\t'ASINH': (x) => Math.asinh(x),\n\t'ATAN': (x) => Math.atan(x),\n\t'ATANH': (x) => Math.atanh(x),\n\t'ATAN2': (y, x) => Math.atan2(y, x),\n\t'CBRT': (x) => Math.cbrt(x),\n\t'CEIL': (x) => Math.ceil(x),\n\t'COS': (x) => Math.cos(x),\n\t'COSH': (x) => Math.cosh(x),\n\t'DIVIDE': (x, y) => x / y,\n\t'EXP': (x) => Math.exp(x),\n\t'EXPM1': (x) => Math.expm1(x),\n\t'FACTORIAL': factorial,\n\t'FLOOR': (x) => Math.floor(x),\n\t'HYPOT': (...args) => Math.hypot(...args),\n\t'LOG': (x) => Math.log(x),\n\t'LOG1P': (x) => Math.log1p(x),\n\t'LOG10': (x) => Math.log10(x),\n\t'LOG2': (x) => Math.log2(x),\n\t'MAX': (...args) => Math.max(...args),\n\t'MEAN': (...args) => [...args].reduce((sum, x) => {\n\t\treturn sum + x;\n\t}, 0) / [...args].length,\n\t'MIN': (...args) => Math.min(...args),\n\t'MOD': (x, y) => x % y,\n\t'MULTIPLY': (x, y) => x * y,\n\t'POW': (x, y) => x ** y,\n\t'SIN': (x) => Math.sin(x),\n\t'SINH': (x) => Math.sinh(x),\n\t'SQRT': (x) => Math.sqrt(x),\n\t'SUBTRACT': (x, y) => x - y,\n\t'SUM': (...args) => [...args].reduce((sum, x) => {\n\t\tsum += x;\n\t\treturn sum;\n\t}, 0),\n\t'TAN': (x) => Math.tan(x),\n\t'TANH': (x) => Math.tanh(x),\n};\n\nexport { symbols, operators, constants, methods }\n","import { symbols, operators, constants, methods } from './config';\n\nconst isSymbol = (token: string): boolean => Object.keys(symbols).includes(token);\nconst isOperator = (token: string): boolean => Object.keys(operators).includes(token);\nconst isMethod = (token: string): boolean => Object.keys(methods).includes(token);\nconst isConstant = (token: string): boolean => Object.keys(constants).includes(token);\nconst isNumber = (token: string): boolean => /(\\d+\\.\\d*)|(\\d*\\.\\d+)|(\\d+)/.test(token);\nconst isOpenParenthesis = (token: string): boolean => /\\(/.test(token);\nconst isCloseParenthesis = (token: string): boolean => /\\)/.test(token);\nconst isComma = (token: string): boolean => /,/.test(token);\nconst isWhitespace = (token: string): boolean => /\\s/.test(token);\n\nconst round = (number: number, precision: number): number => {\n\tconst modifier = 10 ** precision;\n\n\treturn !modifier ? Math.round(number) : Math.round(number * modifier) / modifier;\n};\n\nfunction topOperatorHasPrecedence(operatorStack: string[], currentOperatorName: string): boolean {\n\tif (!operatorStack.length) return false;\n\n\tconst topToken = operatorStack[operatorStack.length - 1];\n\n\tif (!isOperator(topToken)) return false;\n\n\tconst topOperator = operators[topToken];\n\tconst currentOperator = operators[currentOperatorName];\n\n\tif (currentOperator.method.length === 1 && topOperator.method.length > 1) return false;\n\n\tif (topOperator.precedence > currentOperator.precedence) return true;\n\n\treturn topOperator.precedence === currentOperator.precedence && topOperator.associativity === 'left';\n}\n\nfunction determineOperator(token: string, previousToken: string): string {\n\tif (\n\t\tpreviousToken === undefined\n\t\t|| isOpenParenthesis(previousToken)\n\t\t|| isSymbol(previousToken)\n\t\t|| isComma(previousToken)\n\t) {\n\t\treturn symbols[token].prefix;\n\t}\n\n\tif (\n\t\tisCloseParenthesis(previousToken)\n\t\t|| (isNumber(previousToken)\n\t\t|| isConstant(previousToken))\n\t) {\n\t\treturn symbols[token].infix;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Takes a string and parses out the array of tokens in infix notation.\n *\n * @param {string} expression The string.\n *\n * @throws {Error} No input.\n *\n * @returns {string[]} The array of tokens in infix notation.\n */\nfunction parse(expression: string): string[] {\n\tif (!expression.length) {\n\t\tthrow Error('No input');\n\t}\n\n\tconst pattern = /(\\d+\\.\\d*)|(\\d*\\.\\d+)|(\\d+)|([a-zA-Z0-9_]+)|(.)/g;\n\n\tconst infixExpression = (expression.match(pattern) || [])\n\t\t.filter((token) => !isWhitespace(token))\n\t\t.map((token) => token.toUpperCase());\n\n\treturn infixExpression;\n}\n\n/**\n * Takes an array of tokens in infix notation and converts it to postfix notation.\n *\n * @param {string[]} infixExpression The array of tokens in infix notation.\n *\n * @throws {Error} No valid tokens.\n * @throws {Error} Misused operator: <token>.\n * @throws {Error} Mismatched parentheses.\n * @throws {Error} Invalid token: <token>.\n * @throws {Error} Insufficient arguments for method: <token>.\n *\n * @returns {string[]} The array of tokens in postfix notation.\n */\nfunction convert(infixExpression: string[]): string[] {\n\tif (!infixExpression.length) {\n\t\tthrow Error('No valid tokens');\n\t}\n\n\tconst operatorStack = [];\n\tconst arityStack = [];\n\tconst postfixExpression = [];\n\tlet methodIsNewlyDeclared = false;\n\n\tinfixExpression.forEach((token, index) => {\n\t\tif (methodIsNewlyDeclared && !isOpenParenthesis(token)) {\n\t\t\tthrow Error(`Misused method: ${operatorStack[operatorStack.length - 1]}`);\n\t\t}\n\n\t\tmethodIsNewlyDeclared = false;\n\n\t\tif (isMethod(token)) {\n\t\t\tmethodIsNewlyDeclared = true;\n\t\t\toperatorStack.push(token);\n\t\t\tarityStack.push(1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isConstant(token)) {\n\t\t\tpostfixExpression.push(token);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isNumber(token)) {\n\t\t\tpostfixExpression.push(parseFloat(token));\n\t\t\treturn;\n\t\t}\n\n\t\tif (isSymbol(token)) {\n\t\t\tconst operatorName = determineOperator(token, infixExpression[index - 1]);\n\t\t\tconst operator = operators[operatorName];\n\n\t\t\tif (operator === undefined) {\n\t\t\t\tthrow Error(`Misused operator: ${token}`);\n\t\t\t}\n\n\t\t\twhile (topOperatorHasPrecedence(operatorStack, operatorName)) {\n\t\t\t\tpostfixExpression.push(operatorStack.pop());\n\t\t\t}\n\n\t\t\toperatorStack.push(operatorName);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isOpenParenthesis(token)) {\n\t\t\toperatorStack.push(token);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isComma(token)) {\n\t\t\tarityStack[arityStack.length - 1] += 1;\n\n\t\t\twhile (!isOpenParenthesis(operatorStack[operatorStack.length - 1])) {\n\t\t\t\tif (!operatorStack.length) {\n\t\t\t\t\tthrow Error('Invalid token: ,');\n\t\t\t\t}\n\n\t\t\t\tpostfixExpression.push(operatorStack.pop());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (isCloseParenthesis(token)) {\n\t\t\twhile (!isOpenParenthesis(operatorStack[operatorStack.length - 1])) {\n\t\t\t\tif (!operatorStack.length) {\n\t\t\t\t\tthrow Error('Mismatched parentheses');\n\t\t\t\t}\n\n\t\t\t\tpostfixExpression.push(operatorStack.pop());\n\t\t\t}\n\n\t\t\toperatorStack.pop();\n\n\t\t\tif (isMethod(operatorStack[operatorStack.length - 1])) {\n\t\t\t\tconst method = operatorStack[operatorStack.length - 1];\n\t\t\t\tconst argumentCount = arityStack.pop();\n\n\t\t\t\tif (argumentCount < methods[method].length) {\n\t\t\t\t\tthrow Error(`Insufficient arguments for method: ${method}`);\n\t\t\t\t}\n\n\t\t\t\tpostfixExpression.push(`${operatorStack.pop()}:${argumentCount}`);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tthrow Error(`Invalid token: ${token}`);\n\t});\n\n\twhile (operatorStack.length) {\n\t\tconst operator = operatorStack[operatorStack.length - 1];\n\n\t\tif (isOpenParenthesis(operator) || isCloseParenthesis(operator)) {\n\t\t\tthrow Error('Mismatched parentheses');\n\t\t}\n\n\t\tpostfixExpression.push(operatorStack.pop());\n\t}\n\n\treturn postfixExpression;\n}\n\n/**\n * Takes an array of tokens in postfix notation and resolves the result.\n *\n * @param {string[]} postfixExpression The array of tokens in postfix notation.\n *\n * @throws {Error} No operations.\n * @throws {Error} Insufficient arguments for method: <token>.\n * @throws {Error} Insufficient operands for operator: <token>.\n * @throws {Error} Division by zero.\n * @throws {Error} Insufficient operators.\n *\n * @returns {number} The result.\n */\nfunction resolve(postfixExpression: string[]): number {\n\tif (!postfixExpression.length) {\n\t\tthrow Error('No operations');\n\t}\n\n\tconst evaluationStack = [];\n\n\tpostfixExpression.forEach((token) => {\n\t\tif (isMethod(String(token).split(':')[0])) {\n\t\t\tconst [methodName, argumentCount] = token.split(':');\n\t\t\tconst method = methods[methodName];\n\t\t\tconst isVariadic = method.length === 0;\n\t\t\tconst requiredArguments = isVariadic ? 1 : method.length;\n\n\t\t\tif (evaluationStack.length < requiredArguments) {\n\t\t\t\tthrow Error(`Insufficient arguments for method: ${token}`);\n\t\t\t}\n\n\t\t\tconst result = method(...evaluationStack.splice(isVariadic ? -argumentCount : -method.length));\n\t\t\tevaluationStack.push(result);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isConstant(token)) {\n\t\t\tevaluationStack.push(constants[token]);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isNumber(token)) {\n\t\t\tevaluationStack.push(token);\n\t\t\treturn;\n\t\t}\n\n\t\tconst operator = operators[token];\n\n\t\tif (evaluationStack.length < operator.method.length) {\n\t\t\tthrow Error(`Insufficient operands for operator: ${operator.name}`);\n\t\t}\n\n\t\tif (token === '_DIV' && evaluationStack[1] === 0) {\n\t\t\tthrow Error('Division by zero');\n\t\t}\n\n\t\tconst result = operator.method(...evaluationStack.splice(-operator.method.length));\n\t\tevaluationStack.push(result);\n\t});\n\n\tif (evaluationStack.length > 1) {\n\t\tthrow Error('Insufficient operators');\n\t}\n\n\tconst reduction = evaluationStack[0];\n\tconst result = round(reduction, 8);\n\n\treturn result;\n}\n\n/**\n * Takes a string and evaluates the result.\n *\n * @param {string} expression The string.\n *\n * @throws {Error} No input.\n * @throws {Error} No valid tokens.\n * @throws {Error} Misused operator: <token>.\n * @throws {Error} Mismatched parentheses.\n * @throws {Error} Invalid token: <token>.\n * @throws {Error} No operations.\n * @throws {Error} Insufficient arguments for method: <token>.\n * @throws {Error} Insufficient operands for operator: <token>.\n * @throws {Error} Division by zero.\n * @throws {Error} Insufficient operators.\n *\n * @returns {number} The result.\n */\nexport default function (expression: string): number {\n\ttry {\n\t\tconst infixExpression = parse(expression);\n\t\tconst postfixExpression = convert(infixExpression);\n\t\tconst result = resolve(postfixExpression);\n\t\treturn result;\n\t} catch (error) {\n\t\tthrow error;\n\t}\n}\n"],"names":["const","symbols","infix","prefix","factorial","x","NaN","operators","name","precedence","associativity","method","y","constants","Math","E","LN2","LN10","LOG2E","LOG10E","sqrt","PI","SQRT1_2","SQRT2","methods","abs","acos","acosh","asin","asinh","atan","atanh","atan2","cbrt","ceil","cos","cosh","exp","expm1","floor","hypot","args","log","log1p","log10","log2","max","reduce","sum","length","min","sin","sinh","tan","tanh","isSymbol","token","Object","keys","includes","isOperator","isMethod","isConstant","isNumber","test","isOpenParenthesis","isCloseParenthesis","isComma","topOperatorHasPrecedence","operatorStack","currentOperatorName","topToken","topOperator","currentOperator","expression","postfixExpression","Error","number","modifier","evaluationStack","forEach","String","split","isVariadic","result","splice","argumentCount","push","operator","round","resolve","infixExpression","arityStack","methodIsNewlyDeclared","index","parseFloat","operatorName","previousToken","undefined","determineOperator","pop","convert","match","filter","isWhitespace","map","toUpperCase","parse","error"],"mappings":"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"}